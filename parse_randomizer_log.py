import re
import argparse

# TODO: figure out a better iteration method
# than repeating the file boilerplate

def is_wild_pokemon_set(line):
    return re.match(r"^Set \#\d{1,3}.*", line) is not None


def extract_pkmn_from_wild_set(pkmn_set):
    # \u2640 and \u2642 are the nidoran gender symbols
    # expand the list of explicitly allowed symbols as needed
    # TODO: find a better way to handle the edge cases of the mime family
    pkmn_regex = re.compile(
        "(?:(?P<PKMN>(\\w|[-.â€™'\u2640\u2642]|Mr. Mime|Mime Jr.)*) (Lv(s)? ?\\d{1,3}(-\\d{1,3})?))", flags=re.I)
    match_iter = pkmn_regex.finditer(pkmn_set)
    for match in match_iter:
        yield match.group("PKMN")


def extract_location_from_line(line):
    location = re.compile("- (?P<LOC>.*) \\(rate")
    return location.search(line).group("LOC")


def get_wild_sets(lines):
    return [line for line in lines if is_wild_pokemon_set(line)]


def get_wild_pkmn(wild_sets):
    pkmn_set = set()
    for ws in wild_sets:
        pkmn_set |= set(extract_pkmn_from_wild_set(ws))
    return pkmn_set


def get_pkmn_locations(wild_sets, pkmn):
    locations = set()
    for ws in wild_sets:
        available_pkmn = map(str.lower, list(extract_pkmn_from_wild_set(ws)))
        if pkmn.lower() in available_pkmn:
            locations.add(extract_location_from_line(ws))
    return locations


def get_wild_pkmn_with_locations(wild_sets):
    pkmn_set = set()
    pkmn_locations = dict()
    for ws in wild_sets:
        curr_pkmn = set(extract_pkmn_from_wild_set(ws))
        curr_loc = extract_location_from_line(ws)
        for pkmn in curr_pkmn:
            if pkmn in pkmn_set:
                pkmn_locations[pkmn].append(curr_loc)
            else:
                pkmn_locations[pkmn] = [curr_loc]
        pkmn_set |= curr_pkmn
    return (pkmn_set, pkmn_locations)


def extract_from_file(logfile, with_locations):
    lines = logfile.readlines()
    wild_sets = get_wild_sets(lines)
    return get_wild_pkmn_with_locations(wild_sets) if with_locations else get_wild_pkmn(wild_sets)


def find_pokemon_locations_in_file(logfile, pkmn):
    lines = logfile.readlines()
    wild_sets = get_wild_sets(lines)
    return get_pkmn_locations(wild_sets, pkmn)


def write_wild_pkmn_to_file(writefile, pkmn_set):
    for pkmn in pkmn_set:
        writefile.write(f"{pkmn}\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser("parse_randomizer_log")
    parser.add_argument(
        "logfile",
        help="The logfile generated by the randomizer",
        type=argparse.FileType('r', encoding="utf-8"))

    parser.add_argument(
        "-o",
        "--outfile",
        help="File to write the possible wild Pokemon to",
        type=argparse.FileType('w', encoding="utf-8")
    )

    parser.add_argument("-f", "--find",
                        help="Pokemon to retrieve all possible locations for")

    parser.add_argument(
        "--withloc",
        help="Extract pokemon and attach a list of their locations",
        action=argparse.BooleanOptionalAction)

    args = parser.parse_args()

    if args.find:
        print(f"finding locations of {args.find}")
        res = find_pokemon_locations_in_file(args.logfile, args.find)
    elif args.withloc:
        print(f"grabbing pokemon and their locations")
        (pkmn, locs) = extract_from_file(args.logfile, True)
        res = [f"{p}: {', '.join(locs[p])}" for p in pkmn]
    else:
        print(f"grabbing pokemon")
        pkmn = extract_from_file(args.logfile, False)
        res = list(pkmn)

    if args.outfile:
        write_wild_pkmn_to_file(args.outfile, res)
    else:
        print(res)
