import re
import argparse

# TODO: figure out a better iteration method
# than repeating the file boilerplate

def is_wild_pokemon_set(line):
    return re.match(r"^Set \#\d{1,3}.*", line) is not None


def extract_pkmn_from_wild_set(pkmn_set):
    # \u2640 and \u2642 are the nidoran gender symbols
    # expand the list of explicitly allowed symbols as needed
    # TODO: find a better way to handle the edge cases of the mime family
    pkmn_regex = re.compile(
        "(?:(?P<PKMN>(\\w|[-.â€™'\u2640\u2642]|Mr. Mime|Mime Jr.)*) (Lv(s)? ?\\d{1,3}(-\\d{1,3})?))", flags=re.I)
    match_iter = pkmn_regex.finditer(pkmn_set)
    for match in match_iter:
        yield match.group("PKMN")


def extract_location_from_line(line):
    location = re.compile("- (?P<LOC>.*) \\(rate")
    return location.search(line).group("LOC")


def get_pkmn_location_from_log_file(logfile, pkmn):
    locations = set()
    with open(logfile, "r", encoding="utf-8") as log:
        lines = log.readlines()
        for line in lines:
            if is_wild_pokemon_set(line):
                available_pkmn = map(str.lower, list(
                    extract_pkmn_from_wild_set(line)))
                if pkmn.lower() in available_pkmn:
                    locations.add(extract_location_from_line(line))
    return locations


def extract_wild_pkmn_from_log_file(logfile):
    pkmn_set = set()
    with open(logfile, "r", encoding="utf-8") as log:
        lines = log.readlines()
        for line in lines:
            if (is_wild_pokemon_set(line)):
                pkmn_set |= set(extract_pkmn_from_wild_set(line))
    return pkmn_set


def extract_wild_pkmn_with_locations(logfile):
    pkmn_set = set()
    pkmn_locations = dict()
    with open(logfile, "r", encoding="utf-8") as log:
        lines = log.readlines()
        for line in lines:
            if (is_wild_pokemon_set(line)):
                curr_pkmn = set(extract_pkmn_from_wild_set(line))
                curr_loc = extract_location_from_line(line)
                for pkmn in curr_pkmn:
                    if pkmn in pkmn_set:
                        pkmn_locations[pkmn].append(curr_loc)
                    else:
                        pkmn_locations[pkmn] = [curr_loc]
                pkmn_set |= curr_pkmn
    return (pkmn_set, pkmn_locations)


def write_wild_pkmn_to_file(writefile, pkmn_set):
    with open(writefile, "w", encoding="utf-8") as output:
        for pkmn in pkmn_set:
            output.write(f"{pkmn}\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser("parse_randomizer_log")
    parser.add_argument(
        "logfile",
        help="The logfile generated by the randomizer",
        type=str)

    parser.add_argument(
        "-o",
        "--outfile",
        help="File to write the possible wild Pokemon to",
        type=str
    )

    parser.add_argument("-f", "--find",
                        help="Pokemon to retrieve all possible locations for")

    parser.add_argument(
        "--withloc",
        help="Extract pokemon and attach a list of their locations",
        action=argparse.BooleanOptionalAction)

    args = parser.parse_args()

    if args.find:
        print(f"finding locations of {args.find}")
        res = get_pkmn_location_from_log_file(args.logfile, args.find)
    elif args.withloc:
        print(f"grabbing pokemon and their locations")
        (pkmn, locs) = extract_wild_pkmn_with_locations(args.logfile)
        res = [f"{p}: {', '.join(locs[p])}" for p in pkmn]

    if args.outfile:
        write_wild_pkmn_to_file(args.outfile, res)
    else:
        print(res)
